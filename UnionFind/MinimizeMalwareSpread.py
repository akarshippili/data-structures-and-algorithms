class Solution:
    def minMalwareSpread(self, graph, initial):

        N = len(graph)
        uf = UnionFind(N)
        

        for i in initial: uf.numOfMalwareSources[i] = 1

        for i in range(N):
            for j in range(i+1, N):
                if(graph[i][j] == 1): uf.merge(i, j)
        

        print(uf.id, uf.numOfMalwareSources, uf.size)

        ans_index = -1
        ans_component_size = -1

        for comp_index in initial:
            comp_root = uf.find(comp_index)
            if(uf.numOfMalwareSources[comp_root] == 1):
                cur_comp_size = uf.getComponentSize(comp_root)
                if(cur_comp_size > ans_component_size):
                    ans_component_size = cur_comp_size
                    ans_index = comp_index
                elif(cur_comp_size == ans_component_size):
                    ans_index = min(ans_index, comp_index)
        
        if(ans_index == -1): return min(initial)
        return ans_index





class UnionFind:

    def __init__(self, n):
        self.numberOfElements = n
        self.numOfComponents = n
        self.id = [i for i in range(self.numberOfElements)]
        self.size = [1 for i in range(self.numberOfElements)]
        self.numOfMalwareSources = [0 for i in range(self.numberOfElements)]


    def getNumberOfComponents(self): return self.numOfComponents

    def find(self, index): 
        root = index
        while(self.id[root] != root): root = self.id[root]

        # now val in root is the current component's root
        # path compression
        while(index != root): index, self.id[index] = self.id[index], root

        return root

    def isConnected(self, component1, component2): return self.find(component1) == self.find(component2)

    def getComponentSize(self, component): return self.size[self.find(component)]

    def merge(self, component1, component2):
        print(component1, component2)
        firstComponentRoot = self.find(component1)
        secondComponentRoot = self.find(component2)

        # already connected return 
        if(firstComponentRoot == secondComponentRoot): return

        componentSize1 = self.size[firstComponentRoot]
        componentSize2 = self.size[secondComponentRoot]
        self.numOfComponents -= 1 

        if(componentSize1 >= componentSize2):            
            self.size[firstComponentRoot] += self.size[secondComponentRoot]
            self.numOfMalwareSources[firstComponentRoot] += self.numOfMalwareSources[secondComponentRoot]
            self.id[secondComponentRoot] = firstComponentRoot
        else:
            self.size[secondComponentRoot] += self.size[firstComponentRoot]
            self.numOfMalwareSources[secondComponentRoot] += self.numOfMalwareSources[firstComponentRoot]
            self.id[firstComponentRoot] = secondComponentRoot


solution = Solution()
# solution.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1])
ans = solution.minMalwareSpread([[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,1,0],[0,0,0,1,1,0],[0,0,0,0,0,1]], [5,0])
print(ans)

